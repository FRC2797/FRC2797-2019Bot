// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2797.Robot2019.subsystems;


import com.kauailabs.navx.frc.AHRS;

import org.usfirst.frc2797.Robot2019.commands.TeleopDrive;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SPI;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drivetrain extends Subsystem implements PIDOutput {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Spark frontRight;
    private Spark rearRight;
    private SpeedControllerGroup rightDrive;
    private Spark frontLeft;
    private Spark rearLeft;
    private SpeedControllerGroup leftDrive;
    private DifferentialDrive tankDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private Encoder leftEnc;
    private Encoder rightEnc;

    private final AHRS navX;

    private final PIDController leftPID;
    private final PIDController rightPID;
    private final PIDController gyroPID;
    

    double rotateToAngleRate;
    private final double wheelDiameter = 0.5;
    private final double wheelCircumference = wheelDiameter*Math.PI;

    public Drivetrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        frontRight = new Spark(0);
        addChild("frontRight",frontRight);
        frontRight.setInverted(false);
        
        rearRight = new Spark(1);
        addChild("rearRight",rearRight);
        rearRight.setInverted(false);
        
        rightDrive = new SpeedControllerGroup(frontRight, rearRight  );
        addChild("rightDrive",rightDrive);
        
        
        frontLeft = new Spark(2);
        addChild("frontLeft",frontLeft);
        frontLeft.setInverted(false);
        
        rearLeft = new Spark(3);
        addChild("rearLeft",rearLeft);
        rearLeft.setInverted(false);
        
        leftDrive = new SpeedControllerGroup(frontLeft, rearLeft  );
        addChild("leftDrive",leftDrive);
        
        
        tankDrive = new DifferentialDrive(rightDrive, leftDrive);
        addChild("TankDrive",tankDrive);
        tankDrive.setSafetyEnabled(true);
        tankDrive.setExpiration(0.1);
        tankDrive.setMaxOutput(1.0);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        leftEnc = new Encoder(2, 3, true, EncodingType.k2X);
        addChild("Drivetrain Left Encoder", leftEnc);
        leftEnc.setDistancePerPulse(1.0);
        leftEnc.setPIDSourceType(PIDSourceType.kDisplacement);

        rightEnc = new Encoder(0, 1, true, EncodingType.k2X);
        addChild("Drivetrain Right Encoder", rightEnc);
        rightEnc.setDistancePerPulse(1.0);
        rightEnc.setPIDSourceType(PIDSourceType.kDisplacement);

        navX = new AHRS(SPI.Port.kMXP);


        leftPID = new PIDController(0.0075, 0.01, 0.0, 0.0, leftEnc, leftDrive);
        addChild("Drivetrain Left PID", leftPID);
        leftPID.setAbsoluteTolerance(1000.0);
        leftPID.setInputRange(Double.MIN_VALUE, Double.MAX_VALUE);
        leftPID.setOutputRange(-1.0, 1.0);
        leftPID.setContinuous(false);

        rightPID = new PIDController(0.0075, 0.01, 0.0, 0.0, leftEnc, rightDrive);
        addChild("Drivetrain Right PID", rightPID);
        rightPID.setAbsoluteTolerance(1000.0);
        rightPID.setInputRange(Double.MIN_VALUE, Double.MAX_VALUE);
        rightPID.setOutputRange(-1.0, 1.0);
        rightPID.setContinuous(false);

        gyroPID = new PIDController(0.03, 0.01, 0.0, navX, this);
        addChild("Drivetrain Gyro PID", gyroPID);
        gyroPID.setAbsoluteTolerance(1.0);
        gyroPID.setInputRange(-360.0, 360.0);
        gyroPID.setOutputRange(-1.0, 1.0);
        gyroPID.setContinuous(false);


    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TeleopDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /**
     * Drive the robot using the input speed values.
     * @param leftSpeed The speed of the left wheels.
     * @param rightSpeed The speed of the right wheels.
     */
    public void drive(double leftSpeed, double rightSpeed){
        tankDrive.tankDrive(-leftSpeed, -rightSpeed);
    }

    /**
     * Reset the yaw on the navx.
     */
    public void resetYaw(){
        navX.zeroYaw();
    }

    /**
     * Reset the drivetrain encoders.
     */
    public void resetEncoders(){
        leftEnc.reset();
        rightEnc.reset();
    }

    /**
     * Disables all PIDControllers in the drivetrain
     */
    public void disablePIDControllers(){
        leftPID.disable();
        rightPID.disable();
        gyroPID.disable();
    }

    /**
     * Turn the robot by a specific degree measure. This is relative to the current rotation.
     * @param angle The angle of rotation (in degrees).
     * @param speed The maximum speed at which to rotate (0.0-1.0).
     */
    public void turnToAngle(double angle, double speed){
        //Set the output range of the gyroPID to the value of 'speed'.
        gyroPID.setOutputRange(-speed, speed);

        //Disable all PIDControllers
        disablePIDControllers();

        //Zero the yaw (y-axis rotation) of the navx.
        resetYaw();

        //Change the setpoint of the gyroPID to the value of 'angle'.
        gyroPID.setSetpoint(angle);

        //Set this variable to zero. For reasons.
        rotateToAngleRate = 0.0;

        //Enable the gyroPID.
        gyroPID.enable();

        //While the gyroPID is enabled...
        while(gyroPID.isEnabled()){
            //...Rotate the robot.
            tankDrive.tankDrive(rotateToAngleRate, -rotateToAngleRate);

            //When the setpoint is reached, disable the gyroPID.
            if(gyroPID.onTarget())
                gyroPID.disable();
        }
    }

    /**
     * Automatically drive a specific distance. This is relative to the current position.
     * @param distance The distance to be driven (in feet).
     * @param speed The maximum speed at which to drive (0.0-1.0).
     */
    public void driveDistance(double distance, double speed){
        //Set the output ranges of leftPID and rightPID to the value of 'speed'.
        leftPID.setOutputRange(-speed, speed);
        rightPID.setOutputRange(-speed, speed);

        //Disable all PIDControllers.
        disablePIDControllers();

        //Zero the encoders.
        resetEncoders();

        //Change the leftPID and rightPID setpoints using an equation that takes the input distance and turns it into an encoder count.
        leftPID.setSetpoint((int)(distance*(360/wheelCircumference)));
        rightPID.setSetpoint((int)(distance*(360/wheelCircumference)));

        //Enable leftPID and rightPID.
        leftPID.enable();
        rightPID.enable();

        //Disable each PIDController once it reaches its setpoint.
        while(leftPID.isEnabled() || rightPID.isEnabled()){
            if(leftPID.onTarget())
                leftPID.disable();
            if(rightPID.onTarget())
                rightPID.disable();
        }
    }

    public void pidWrite(double output){
        rotateToAngleRate = output;
    }
}
